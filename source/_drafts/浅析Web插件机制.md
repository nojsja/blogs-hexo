---
title: 浅析 Web 插件机制
subtitle: 浅析 Web 插件机制
catalog: true
comments: true
indexing: true
header-img: >-
  https://nojsja.gitee.io/static-resources/images/hexo/article_header/article_header.jpg
top: false
tocnum: true
tags:
  - plugin
categories:
  - Frontend
date: 2022-08-17 21:39:47
---

Contents

- [I. 序言](#i-%E5%BA%8F%E8%A8%80)
- [II. Web 插件的几种应用场景](#ii-web-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
  - [一、助力效率工具的生态构建](#%E4%B8%80%E5%8A%A9%E5%8A%9B%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E7%9A%84%E7%94%9F%E6%80%81%E6%9E%84%E5%BB%BA)
    - [1. 前端的瑞士军刀 - VScode](#1-%E5%89%8D%E7%AB%AF%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80---vscode)
    - [2. 效率工具平台 - Utools](#2-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E5%B9%B3%E5%8F%B0---utools)
  - [二、前端工程化的基石](#%E4%BA%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E5%9F%BA%E7%9F%B3)
    - [1. 开启 Web 新纪元 - Webpack 打包器](#1-%E5%BC%80%E5%90%AF-web-%E6%96%B0%E7%BA%AA%E5%85%83---webpack-%E6%89%93%E5%8C%85%E5%99%A8)
    - [2. 小而美的静态站点构建工具 - Hexo](#2-%E5%B0%8F%E8%80%8C%E7%BE%8E%E7%9A%84%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7---hexo)
  - [三、更好地构建可扩展的网络应用程序](#%E4%B8%89%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)
- [III. 插件机制的核心关注点](#iii-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%85%B3%E6%B3%A8%E7%82%B9)
  - [一、「接口」：插件如何在特定时机和位置接入](#%E4%B8%80%E6%8E%A5%E5%8F%A3%E6%8F%92%E4%BB%B6%E5%A6%82%E4%BD%95%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%97%B6%E6%9C%BA%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%8E%A5%E5%85%A5)
    - [1. 调用时机](#1-%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA)
    - [2. 接入方式](#2-%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F)
  - [二、「输入」：如何将上下文信息高效传递给插件](#%E4%BA%8C%E8%BE%93%E5%85%A5%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%E9%AB%98%E6%95%88%E4%BC%A0%E9%80%92%E7%BB%99%E6%8F%92%E4%BB%B6)
    - [1. 同应用进程内的通信](#1-%E5%90%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E9%80%9A%E4%BF%A1)
    - [2. 同应用跨进程的通信](#2-%E5%90%8C%E5%BA%94%E7%94%A8%E8%B7%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1)
    - [3. 题外话：跨应用间的通信](#3-%E9%A2%98%E5%A4%96%E8%AF%9D%E8%B7%A8%E5%BA%94%E7%94%A8%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1)
  - [三、「输出」：插件内部通过何种方式影响整套运行体系](#%E4%B8%89%E8%BE%93%E5%87%BA%E6%8F%92%E4%BB%B6%E5%86%85%E9%83%A8%E9%80%9A%E8%BF%87%E4%BD%95%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%BD%B1%E5%93%8D%E6%95%B4%E5%A5%97%E8%BF%90%E8%A1%8C%E4%BD%93%E7%B3%BB)
    - [1. 改变主程序的数据输出结果](#1-%E6%94%B9%E5%8F%98%E4%B8%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C)
    - [2. 扩展主程序 UI 功能](#2-%E6%89%A9%E5%B1%95%E4%B8%BB%E7%A8%8B%E5%BA%8F-ui-%E5%8A%9F%E8%83%BD)
    - [3. 统计和分析主程序的运行指标信息](#3-%E7%BB%9F%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E4%B8%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%8C%87%E6%A0%87%E4%BF%A1%E6%81%AF)
- [IV. VSCode 插件系统及其生态](#iv-vscode-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E7%94%9F%E6%80%81)
  - [一、VSCode 插件开发简要介绍](#%E4%B8%80vscode-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D)
  - [二、VSCode 整体架构](#%E4%BA%8Cvscode-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84)
  - [三、VSCode 针对性能优化的实践](#%E4%B8%89vscode-%E9%92%88%E5%AF%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E8%B7%B5)
- [V. Utools 工具的轻插件系统](#v-utools-%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BD%BB%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F)
  - [一、Utools 插件开发简要介绍](#%E4%B8%80utools-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D)
  - [二、Utools 应用中的主进程和渲染进程](#%E4%BA%8Cutools-%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B)
  - [三、Utools 为何采用 Webview 而不是新开渲染进程窗口](#%E4%B8%89utools-%E4%B8%BA%E4%BD%95%E9%87%87%E7%94%A8-webview-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%B0%E5%BC%80%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E7%AA%97%E5%8F%A3)
- [VI. Hexo 静态站点构建工具的插件机制](#vi-hexo-%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6)
  - [一、Hexo 插件开发简要介绍](#%E4%B8%80hexo-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D)
  - [二、Hexo 的一个插件示例](#%E4%BA%8Chexo-%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%A4%BA%E4%BE%8B)
- [VII. Webpack 打包器的插件工作原理](#vii-webpack-%E6%89%93%E5%8C%85%E5%99%A8%E7%9A%84%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [一、Webpack 的工作原理](#%E4%B8%80webpack-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [二、Webpack 的插件机制](#%E4%BA%8Cwebpack-%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6)
- [VIII. Shadowsocks 代理工具的 SIP003 插件系统](#viii-shadowsocks-%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84-sip003-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F)
  - [一、Shadowsocks 的工作原理](#%E4%B8%80shadowsocks-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
  - [二、Shadowsocks 的 SIP003 插件规范](#%E4%BA%8Cshadowsocks-%E7%9A%84-sip003-%E6%8F%92%E4%BB%B6%E8%A7%84%E8%8C%83)
  - [三、本地端口转发的实现原理和示例](#%E4%B8%89%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E7%A4%BA%E4%BE%8B)

## I. 序言

计算机应用程序发展到今天，复杂度已经到了一个层级。每个应用程序都由更加基础的模块和库所构建，这些模块和库负责一个个相对单一的功能，正是由它们自底向上纵向组成了功能更加完整的应用程序。而一个流行的应用或工具生态的构建除了其自身的高可用性、高可靠性外还需要拥有横向的高扩展性。

插件系统作为构建高扩展性应用程序的一个重要部分，是一种非常重要的计算机软件设计和构建模式。拥有高扩展性插件系统的软件应用中，用户不仅作为被动的使用者，也可以通过简单的学习该软件的提供的插件化 API 来为其编写更多扩展功能，成为应用功能的构建者。插件化机制无疑可以提供给软件社区源源不断的活力，而应用开发者籍此可以在应用程序核心的功能更新和维护上投入更多精力，将横向的功能扩展交由社区负责。

本文将从多个流行应用程序的插件系统出发，介绍插件机制的设计思想和实现原理。

## II. Web 插件的几种应用场景

### 一、助力效率工具的生态构建

#### 1. 前端的瑞士军刀 - VScode

VSCode 基于 Electron UI 框架，辅以 C++ 代码混合开发技术打造。作为前端开发中最常用的代码编辑器，除了功能强大、性能优异、更新迅速外，其丰富的插件系统和包含着成千上万插件的插件市场也成为亮点之一。

使用 VScode 的插件 API 可以实现：

- 改变 VS Code 的外观与颜色或文件图标主题 - 主题系统；
- 在 UI 中添加自定义组件和视图 - 扩展工作台功能；
- 创建一个 Webview 来显示用 HTML/CSS/JS 构建的自定义网页 - Webview 支持；
- 支持一种新的编程语言 - 语言功能扩展；
- 支持调试特定的运行时 - 调试器功能扩展；

以下实用插件都是基于 VScode 强大的插件功能实现的：

- 代办事项 - Todo Tree，它可以把代码中的 TODO、FIXME、XXX 等标记提取出来，以树状结构的形式展示在侧边栏中；
- 画图工具 - Drawio Preview，它可以在 VScode 中直接预览和编辑 drawio 的图表；
- AI 编程 - Github Copilot，它可以通过 AI 为开发者提供代码建议，提高开发效率；
- 代码段工具 - Reactjs code snippets，使用它来快捷插入 React 代码模板片段，减少重复的非必要文字输入；
- 驼峰翻译助手 - 可以在编辑器中选中中文然后调用服务器翻译 API 将翻译后的英文以多种格式（大小驼峰、连接符、下划线等）插入到编辑器中；

#### 2. 效率工具平台 - Utools

Utools 也是基于 Electron UI 框架开发的，它的定位是一个效率工具平台，可以通过插件的形式扩展其功能。Utools 作为一个工具平台，提供了插件市场用于用户构建生态。Utools 的插件 API 相比于 VScode 简单很多，因此插件和主应用的集成度也更低，大部分插件的功能比较独立。

以下是 Utools 的一些插件示例：

- 聚合翻译，集成多种翻译服务，例如微软翻译、谷歌翻译、有道云翻译等，可实现将复制的文本翻译成目标语言，省去了复制到浏览器翻译的麻烦；
- 关闭进程，可以通过关键词搜索进程，快速关闭进程；
- 图片处理，可以对图片进行压缩、转换、裁剪等操作；
- OCR 图片识别，可以将图片中的文字识别并复制到剪贴板；

从以上可以看出 Utools 工具的定位是提供系统级别的插件工具，其支持插件独立启用一个窗口，对于进程管理工具开发这样的应用场景显然更合适一点。

### 二、前端工程化的基石

#### 1. 开启 Web 新纪元 - Webpack 打包器

Webpack 的核心功能是将多个模块打包成一个或多个 bundle，这些 bundle 可以在浏览器中运行，也可以在 Node.js 中运行。Webpack 本身只能处理 JavaScript 和 JSON 模块，但 loader 转换器可以将各种类型的资源比如图片、Less 样式语言、Typescript 代码等转换为 JavaScript 模块，这样就可以把它们加入到依赖图中，进行集中化处理。而 Webpack plugin 插件可以用于执行范围更广的任务，包括打包优化、静态资源管理、注入环境变量等。

一些常用的 Webpack loader：

- babel-loader：用于将 ES6+ 代码转换为 ES5 代码，并且可以针对较新语法进行 polyfill 兼容。babel 在处理 Js 代码方面的能力是非常强大的，其生态也比较丰富，因此也可以在 Webpack 中使用 babel-loader 来专门处理 Js。
- less-loader：用于将 Less 预处理器语言编译为 CSS 的 loader。
- thread-loader：利用多进程技术，将 loader 运行在独立的 worker 池中，以防止主进程被阻塞。这对于需要花费大量时间进行编译的 loader 很有用，例如 babel-loader 和 ts-loader。

一些常见的 Webpack plugin：

- HtmlWebpackPlugin：用于生成 HTML 文件，可以将打包后的资源自动注入到 HTML 中。
- HotModuleReplacementPlugin：用于文件更新后热替换的插件。
- ModuleFederationPlugin：模块联邦插件，常在微前端项目中用于公共模块分离和加载，以及子项目间模块复用。具有去中心化特性，每个子应用既可以通过模块联邦插件声明式暴露自己的组件接口用于其它子应用远程加载，又可以声明式加载别的子项目暴露出的组件和模块。

Webpack 的 loader 和 plugin 其实都可以视为 Webpack 插件体系的两个重要组成部分，不计其数的社区插件和 Webpack 灵活的可扩展架构，让它成为日渐强大的构建工具。

#### 2. 小而美的静态站点构建工具 - Hexo

Hexo 是一个静态站点构建工具，其拥有繁多的博客模板可用于快速生成美观易用的静态站点。另外 Hexo 也拥有丰富的插件生态，很多插件是第三方开发者自发为 Hexo 开发的，这些插可以用于在 Hexo 构建过程中修改源代码，也可以侵入源代码的生成过程并分析源代码从而生成额外的资源文件。

之前曾使用 Node.js 作为后台开发过一个博客网站，自己实现后台逻辑的话需要考虑数据库存储、前后端交互、后端 Server 部署啥的。整个流程比较繁杂，在初期可以作为前端开发者个人建站学习的一种方式。

Hexo 简化了上述流程，它将数据存储和数据获取这两方面都通过编译构建然后本地化集成到前端静态资源里。一个例子就是博客网站通常需要翻页功能来获取博客文章，传统开发方式下，获取下一页这个操作由前端脚本发起，并由后端 Server 处理请求并返回，但是使用 Hexo 之后这整个过程都是在本地一次完成的，Hexo 将所有静态资源在本地建立了索引。

使用 Hexo 通常写手只需要关注 markdown 格式文章的编写，其余的网站编译、构建和发布的流程都可以交由框架进行处理，所有的网站内容均会被打包成静态的 HTML/CSS/Js 文件。Hexo 支持自定义插件，也有一个插件社区，如果写手同时具备前端能力的话也可以发布自己的插件到社区里进行开源共享。

Hexo 的一些常用插件：

- hexo-lazyload-image：图片懒加载插件，网页滑动时，当插入图片的位置出现在可视区域时，插件将图片的 src 属性替换为 data-src 属性，从而实现图片懒加载效果。
- hexo-generator-sitemap：可以根据网站的静态文件结构生成网站站点地图 sitemap，方便搜索引擎爬虫抓取网站内容，对网页的 SEO 优化很有效。
- hexo-deploy-git：通过一条命令将生成的静态资源文件部署到预先配置好的 git 仓库，方便网站的发布和更新。

### 三、更好地构建可扩展的网络应用程序

Shadowsocks（简称 SS）是一种基于 Socks5 代理方式的加密传输协议，本工具广泛用于突破防火墙（GFW），以浏览被封锁、遮蔽或干扰的内容。当然别的应用场景也包括使用代理IP地址隐藏服务访问者的真实身份等。

Shadowsocks 的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。例如，用户无法直接访问Google，但代理服务器可以访问，且用户可以直接连接代理服务器，那么用户就可以通过特定软件连接代理服务器，然后由代理服务器获取网站内容并回传给用户，从而实现代理上网的效果。

## III. 插件机制的核心关注点

### 一、「接口」：插件如何在特定时机和位置接入

插件程序作为主程序的功能扩展，需要在主程序运行过程中以特定方式在特定时机进行接入，当然接入后也能通过某种机制从运行环境中移除。

这里提及了 **时机** 和 **方式** 两个关键词，插件接入的方式可以反应一个应用程序的功能模块耦合度，而插件调用时机则和其运行性能会相关啊，所以这两个指标都是插件系统开发的核心关注点。

#### 1. 调用时机

宿主机运行主程序时，插件如果一起无序竞争性的加载，势必会造成瞬时CPU和内存占用增大，从而影响整个应用的运行性能，降低用户体验。所以可以通过懒加载或有序加载的方式来缓解这个问题，懒加载就是当主程序用到这个插件时才进行加载，而有序加载就是通过制定一系列的加载规则让插件按照一定顺序加载，比如先同步阻塞加载插件1，再异步并行加载插件2、3、4，最后同步加载插件5。

举个例子：开源的 Tapable hooks 库，提供了 10 种钩子，支持同步、异步、熔断、循环、waterfall 等调用方式，以此按序控制一些任务的执行：

- SyncHook：同步串行执行钩子；
- AsyncParallelHook：异步并行执行钩子；
- AsyncSeriesHook：异步串行执行钩子；
- ...

以我的某个应用程序为例，我使用 Tapable 来组织应用的生命周期：

- 应用程序准备阶段：定义为同步串行执行钩子节点，注册一些需要在程序正式服务于用户之前的准备任务比如：错误监控程序部署、运行文件完整性检测和修复等都被注册到这个生命周期节点。此阶段任务为正式启动前的必要任务，优先级最高，需要 **立即同步执行**。
- 应用程序启动完成阶段：定义为同步串行执行钩子节点，这个阶段需要注册一些初始化用户界面功能的任务，比如：配置语言功能、探测用户默认语言环境等。本阶段任务优先级较高，需要在应用程序启动完成后 **立即同步执行**。
- 应用程序启动完成阶段2：定义为异步并行执行钩子节点，这个阶段需要注册一些优先级比较低的任务，且他们之间的执行没有强相关性，比如：为用户注册客户端唤醒协议 protocol、进程监控工具的初始化等。任务优先级低采用 **异步并行执行**。
- 应用程序退出前阶段：定义为同步串行执行钩子节点，这个阶段需要注册一些程序退出前的必要任务，比如：将用户配置写入磁盘等。本阶段任务也很关键，为了保证数据正确，需要 **立即同步执行**。

任务都注册好后，随着应用程序运行起来会在各个生命周期节点依次进行该节点注册任务的触发。任务之间不会相互冲突和无序竞争。

#### 2. 接入方式

而另一方面，插件的接入方式也有一定考究。如果插件服务于程序开发和构建阶段那大概率会以源代码的方式接入，成为主程序的一个构建依赖。就像 node_modules 目录中的各色模块一样也可以粗略视为主程序依赖的插件，这类插件大部分面向程序开发者而不是普通用户。

如果插件以二进制可执行文件方式工作的话，插件在使用之前就已经是一个构建完成的独立应用程序了。主程序使用他们时一般需要使用子进程来加载和运行插件，插件和宿主之间的通信也依赖于进程间通信。这类插件的最常见的参数传递方式就是通过命令行参数来实现的，比如运行进程查询命令 PS 时也需要添加命令行执行参数：`ps -ef`。

### 二、「输入」：如何将上下文信息高效传递给插件

插件的目的是扩展主应用的功能，因此插件需要通过某种方式知道主程序的运行环境信息，然后通过运行环境接受宿主的命令并根据环境中的参数设置执行相应的操作。

> 本文中谈到的插件系统大多属于同一个应用的范畴，跨应用间的通信方式可以稍作了解

#### 1. 同应用进程内的通信

当插件和主应用运行在同一个进程内时，插件往往可以直接读取宿主环境暴露的 API。这样强耦合的运行环境下，需要注意插件所需的运行环境依赖版本和宿主提供的环境依赖版本是否相同。

一个例子就是之前做过的一个 Electron 应用进程管理工具的进程 CPU/Memory 采集功能。这个进程管理工具也是以类插件模式提供功能，主引入插件后，插件会自己调用 Electron API 来捕获应用中的所有进程（比如渲染进程、主进程、普通的子进程等）的编号，然后将所有进程号调用另一个库每秒统计一次进程资源占用。

从上述交互过程可以看出，插件强依赖于宿主环境提供的 Electron 框架版本，因此在插件 package.json 配置文件中最好声明插件兼容的 Electron 版本，这样子开发者运行插件过程中就会收到兼容性提示信息，方便排查问题原因。

#### 2. 同应用跨进程的通信

很多时候插件直接作为一个可执行二进制文件提供给主程序调用者，已经作为一个独立编译完成的应用，一般这类插件是主程序需要通过子进程的方式运行，因此无法直接利用宿主环境 API 调用来实现功能。

#### 3. 题外话：跨应用间的通信

### 三、「输出」：插件内部通过何种方式影响整套运行体系

引入的插件服务于主程序，一定会对主程序运行体系造成一些附加效果，常见的有以下三种方式：

#### 1. 改变主程序的数据输出结果

#### 2. 扩展主程序 UI 功能

#### 3. 统计和分析主程序的运行指标信息


## IV. VSCode 插件系统及其生态

### 一、VSCode 插件开发简要介绍

### 二、VSCode 整体架构

### 三、VSCode 针对性能优化的实践

## V. Utools 工具的轻插件系统

### 一、Utools 插件开发简要介绍

### 二、Utools 应用中的主进程和渲染进程

### 三、Utools 为何采用 Webview 而不是新开渲染进程窗口

## VI. Hexo 静态站点构建工具的插件机制

### 一、Hexo 插件开发简要介绍

### 二、Hexo 的一个插件示例

## VII. Webpack 打包器的插件工作原理

### 一、Webpack 的工作原理

### 二、Webpack 的插件机制

## VIII. Shadowsocks 代理工具的 SIP003 插件系统

### 一、Shadowsocks 的工作原理

### 二、Shadowsocks 的 SIP003 插件规范

### 三、本地端口转发的实现原理和示例
